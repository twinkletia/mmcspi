#include "mmcspi_slave.h"

#define CMD0 	0x40_00_00_00_00_95
#define CMD1    0x41_00_00_00_00_f9
/* 512 byte */
#define CMD16	0x50_00_00_02_00_01
#define CMD17	0x51_00_00_00_00_01
#define CMD24	0x58_00_00_00_00_01

#define CMD17_18_24_TOKEN 8'b11111110
#define CMD25_TOKEN 8'b11111100
#define CMD25_STOP 8'b11111101

module mmcspi_slave {
	state_name s1, s2, s3, s4, s4_5, s5, s6, s7, s8, s9, busy;
	reg cmd_buf[48] = -1;
	reg cmd_buf_bit_pos[6] = 0;
	reg response_buf[40] = 0;
	reg response_buf_bit_pos[8] = 0;
	reg response_size[8] = 0;
	reg read_op = 0;
	reg write_op = 0;
	reg block_bit_pos[16] = 0;
	reg block_size[16] = 4096;
	reg block_data[4096] = 0;
	reg start_byte[8] = 0xfe;
	reg start_byte_buf[8] = 0;
	reg csd[128] = 0xb5000150_01ffffff_8dc15ada_4c007a00;//005e0032_5b5a83b1_ffffff80_0a8000ad;
	reg cid[128] = 0xa91a8000_ace35b0c_42e24c22_ca120ae4;//27504853_44324742_30dac735_00015895;
	reg scr[64] = 0x00000080_0001a440; //0x2258000_01000000
	reg ocr[32] = 0x80ff8000;
	reg ssr[128] = 0x0000D500_4009C0C0_14000000_00000000 ;//00000000 00000028 03039002 00ab0000 before 384bit is 0
	reg r1resp[8] = 0x00;
	reg r2resp[8] = 0x00;
	reg busy_flag = 0;
	reg acmd_flag = 0;
	reg erase_head[32] = 0;
	reg erase_tail[32] = 0;
	reg exception_ptr[4] = 0;
	reg group_flag = 0;
	mem erase_exception[16][32];
	
	state s1 if(CS == LOW){
			if(cmd_buf_bit_pos == 48-1) {
				cmd_buf_bit_pos := 0;
				goto s2;
			} else {
				cmd_buf_bit_pos++;
			}
			cmd_buf := {cmd_buf[46:0], MOSI};
		MISO = HIGH;
	}
	state s2 {
		wire cmd[6];
		wire arg[32];
		cmd = cmd_buf[45:40];
		arg = cmd_buf[39:8];
		//_display(" CMD%d 0xARG %h ",cmd,arg);
			any {
				cmd_buf == CMD0:	{response_buf := 40'(1'b1); response_size := 8-1; goto s3;}
				cmd_buf == CMD1:	{response_buf := 40'(1'b0); response_size := 8-1; goto s3;}
				cmd_buf == CMD16:	{response_buf := 40'(1'b0); response_size := 8-1; goto s3;}
				cmd == 9:{
					response_buf := 40'({r1resp,start_byte});
					response_size := 16-1; 
					read_op := 1; 
					block_data := 4096'(csd); 
					block_size := 128; goto s3;}		//read csd
				cmd == 10:{
					response_buf := 40'({r1resp,start_byte}); 
					response_size := 16-1; 
					read_op := 1; 
					block_data := 4096'(cid); 
					block_size := 128; goto s3;}	//read cid
				cmd == 12:{}	//force stop multi read
				cmd == 13:{
					if(acmd_flag){
						acmd_flag := 0;
						response_buf := 40'({r1resp,r2resp,start_byte}); 
						response_size := 24-1; 
						read_op := 1; 
						block_data := 4096'(ssr); 
						block_size := 512; goto s3;
					}else{
						response_buf := 40'({r1resp,r2resp}); response_size := 16-1; goto s3;
					}
				}	//read card status
				cmd == 17:{
					response_buf := 40'({r1resp,start_byte}); response_size := 16-1;	//[15:8]00 = recv_cmd17_resp [7:0]fe = master.start_byte
				 	read_op := 1; block_bit_pos := 0;
					read(arg);
				   	block_size := 4096;
				    goto s3;}	//read single block
				cmd == 18:{}	//read multi block
				cmd == 23:{}	//set multi r/w block count
				cmd == 24:{
					response_buf := 40'(r1resp); response_size := 8-1;		//[7:0]00 = recv_cmd24_resp
				 	write_op := 1; block_bit_pos := 0;
				   	block_size := 4096;
				    goto s3;}	//write single block
				cmd == 25:{}	//write multi block
				cmd == 32:{response_buf := 40'(r1resp); response_size := 8-1; erase_head := arg; _display("\n ERASE START ADDR %h ",arg); group_flag := 0; goto s3;}	//select erase head
				cmd == 33:{response_buf := 40'(r1resp); response_size := 8-1; erase_tail := arg; _display("\n ERASE END ADDR %h ",arg); goto s3;}	//select erase tail
				cmd == 34:{response_buf := 40'(r1resp); response_size := 8-1; erase_exception[exception_ptr] := arg; exception_ptr++;  _display("\n ERASE EXCEPTION %h ",arg); goto s3;}	//select erase exception block
				cmd == 35:{response_buf := 40'(r1resp); response_size := 8-1; erase_head := arg; _display("\n ERASE GROUP START ADDR %h ",arg); group_flag := 1; goto s3;}	//select erase group head
				cmd == 36:{response_buf := 40'(r1resp); response_size := 8-1; erase_tail := arg; _display("\n ERASE GROUP END ADDR %h ",arg); goto s3;}	//select erase group tail
				cmd == 37:{response_buf := 40'(r1resp); response_size := 8-1; erase_exception[exception_ptr] := arg; exception_ptr++;  _display("\n ERASE GROUP EXCEPTION %h ",arg); goto s3;}	//select erase group exception block
				cmd == 38:{response_buf := 40'(r1resp); response_size := 8-1; busy_flag := 1;
					erase(erase_head, erase_tail, exception_ptr, 
					{erase_exception[15], erase_exception[14], erase_exception[13], erase_exception[12], 
					erase_exception[11], erase_exception[10], erase_exception[9], erase_exception[8], 
					erase_exception[7], erase_exception[6], erase_exception[5], erase_exception[4], 
					erase_exception[3], erase_exception[2], erase_exception[1], erase_exception[0]},group_flag);
					exception_ptr := 0;
					goto s3;}	//erase
				cmd == 51:{
					acmd_flag := 0;
					response_buf := 40'({r1resp,start_byte}); 
					response_size := 16-1; 
					read_op := 1; 
					block_data := 4096'(scr); 
					block_size := 64; goto s3;}	//read cid
				cmd == 55:{
					response_buf := 40'({r1resp}); 
					response_size := 8-1;
					acmd_flag := 1;
					 goto s3;
					 }	//read cid
				cmd == 58:{response_buf := {r1resp,ocr}; response_size := 40-1; goto s3;}	//read ocr
				else: {response_buf := 40'(0x04); response_size := 8-1; goto s3;}	//unsupported command(response illegal cmd bit)
			}
		MISO = HIGH;
	}
	func block_data_valid {
		block_data := read_block_data;
	}
	state s3 {
			if(response_buf_bit_pos == response_size) {
				response_buf_bit_pos := 0;
				if(read_op) {
					goto s4;
				}else if(write_op){
					goto s5;
				}else if(busy_flag){
					goto busy;
				}else {
					goto s1;
				}
			} else {
				response_buf_bit_pos++;
			}
		MISO = response_buf[response_size-response_buf_bit_pos];
	}
	state s4 {
			if(block_bit_pos == (block_size-1)) {
				block_bit_pos := 0;
				goto s4_5;
			} else {
				block_bit_pos++;
			}
		MISO = block_data[block_bit_pos];
	}
	state s4_5 {
			if(block_bit_pos == (16-1)) {
				block_bit_pos := 0;
				read_op := 0;
				goto s1;
			} else {
				block_bit_pos++;
			}
		MISO = HIGH;
	}
	state s5{	//recv start byte
				if({start_byte_buf[6:0], MOSI} == start_byte) {
					start_byte_buf := 0;
					goto s6;
				} else {
					start_byte_buf := {start_byte_buf[6:0], MOSI};
				}
		MISO = HIGH;
	}
	state s6{	//send block data
				if(block_bit_pos == (4096-1)) {
					//valid({data_block[4094:0], miso});
					block_bit_pos := 0;
					goto s7;
				} else {
					block_bit_pos++;
				}
				block_data := {block_data[4094:0], MOSI};
		MISO = HIGH;
	}
	state s7{	//recv crc
		reg crc_bit_pos[4] = 0;

				if(crc_bit_pos == (16-1)) {
					crc_bit_pos := 0;
					goto s8;
				} else {
					crc_bit_pos++;
				}
				//crc := {crc[14:0], miso};
		MISO = HIGH;
	}
	state s8{	//send data resp
		reg write_response[8] = 0x05;
			if(response_buf_bit_pos == 7) {
				response_buf_bit_pos := 0;
				goto s9;
			} else {
				response_buf_bit_pos++;
			}
		MISO = write_response[response_size-response_buf_bit_pos];//response_buf[response_size-response_buf_bit_pos];
	}
	state s9{	//write busy wait
		write_op := 0;
		write(cmd_buf[39:8], block_data);
		goto s1;
		MISO = HIGH;	//not busy
	}
	state busy{
		reg busy_cnt[5] = 0;
			if(busy_cnt == 31) {
				busy_cnt := 0;
				busy_flag := 0;
				goto s1;
			} else {
				busy_cnt++;
			}
		if(busy_cnt >= 24){
			MISO = HIGH;
		}else{
			MISO = LOW;
		}
	}
}
