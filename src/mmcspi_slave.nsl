#include "mmcspi_slave.h"

#define CMD0 	0x40_00_00_00_00_95
#define CMD1    0x41_00_00_00_00_f9
/* 512 byte */
#define CMD16	0x50_00_00_02_00_01
#define CMD17	0x51_00_00_00_00_01
#define CMD24	0x58_00_00_00_00_01

#define CMD17_18_24_TOKEN 8'b11111110
#define CMD25_TOKEN 8'b11111100
#define CMD25_STOP 8'b11111101

module mmcspi_slave {
	state_name s0, s1, s2, s3, s4, s5, s6, s7, s8, busy;
	reg cmd_buf[48] = -1;
	reg cmd_buf_bit_pos[6] = 0;
	func_self rising_edge;
	reg clk_prev = 0;
	reg mosi = 1;
	reg response_buf[40] = 0;
	reg response_buf_bit_pos[8] = 0;
	reg response_size[8] = 0;
	reg read_op = 0;
	reg write_op = 0;
	reg block_bit_pos[16] = 0;
	reg block_size[16] = 4096;
	reg block_data[4096] = 0;
	reg start_byte[8] = 0xfe;
	reg start_byte_buf[8] = 0;
	reg csd[128] = 0xb5000150_01ffffff_8dc15ada_4c007a00;//005e0032_5b5a83b1_ffffff80_0a8000ad;
	reg cid[128] = 0xa91a8000_ace35b0c_42e24c22_ca120ae4;//27504853_44324742_30dac735_00015895;
	reg ocr[32] = 0x80ff8000;
	reg r1resp[8] = 0x00;
	reg r2resp[8] = 0xAB;
	reg busy_flag = 0;
	reg erase_head[32] = 0;
	reg erase_tail[32] = 0;
	reg exception_ptr[4] = 0;
	mem erase_exception[16][32];

	clk_prev := SCLK;
	
	if(~clk_prev && SCLK) {
		rising_edge();
		mosi := MOSI;
	}
	state s0 {
		if((CS == LOW) && rising_edge) {
			goto s1;
		}
		MISO = HIGH;
	}
	state s1 {
		if(rising_edge) {
			if(cmd_buf_bit_pos == 48-1) {
				cmd_buf_bit_pos := 0;
				goto s2;
			} else {
				cmd_buf_bit_pos++;
			}
			cmd_buf := {cmd_buf[46:0], mosi};
		}
		MISO = HIGH;
	}
	state s2 {
		wire cmd[6];
		wire arg[32];
		cmd = cmd_buf[45:40];
		arg = cmd_buf[39:8];
		_display(" CMD%d \n",cmd);
		_display(" ARG%h \n",arg);
		if(rising_edge) {
			any {
				cmd_buf == CMD0:	{response_buf := 40'(1'b1); response_size := 8-1; goto s3;}
				cmd_buf == CMD1:	{response_buf := 40'(1'b0); response_size := 8-1; goto s3;}
				cmd_buf == CMD16:	{response_buf := 40'(1'b0); response_size := 8-1; goto s3;}
				cmd == 9:{
					response_buf := 40'({r1resp,start_byte});
					response_size := 16-1; 
					read_op := 1; 
					block_data := 4096'(csd); 
					block_size := 128; goto s3;}		//read csd
				cmd == 10:{
					response_buf := 40'({r1resp,start_byte}); 
					response_size := 16-1; 
					read_op := 1; 
					block_data := 4096'(cid); 
					block_size := 128; goto s3;}	//read cid
				cmd == 12:{goto s0;}	//force stop multi read
				cmd == 13:{response_buf := 40'({r1resp,r2resp}); response_size := 16-1; goto s3;}	//read card status
				cmd == 17:{
					response_buf := 40'({r1resp,start_byte}); response_size := 16-1;	//[15:8]00 = recv_cmd17_resp [7:0]fe = master.start_byte
				 	read_op := 1; block_bit_pos := 0;
					read(arg);
				   	block_size := 4096;
				    goto s3;}	//read single block
				cmd == 18:{goto s0;}	//read multi block
				cmd == 23:{goto s0;}	//set multi r/w block count
				cmd == 24:{
					response_buf := 40'(r1resp); response_size := 8-1;		//[7:0]00 = recv_cmd24_resp
				 	write_op := 1; block_bit_pos := 0;
				   	block_size := 4096;
				    goto s3;}	//write single block
				cmd == 25:{goto s0;}	//write multi block
				cmd == 32:{response_buf := 40'(r1resp); response_size := 8-1; erase_head := arg; goto s3;}	//select erase head
				cmd == 33:{response_buf := 40'(r1resp); response_size := 8-1; erase_tail := arg; goto s3;}	//select erase tail
				cmd == 34:{response_buf := 40'(r1resp); response_size := 8-1; erase_exception[exception_ptr] := arg; exception_ptr++; goto s3;}	//select erase exception block
				cmd == 38:{response_buf := 40'(r1resp); response_size := 8-1; busy_flag := 1;
					erase(erase_head, erase_tail, exception_ptr, 
					{erase_exception[0], erase_exception[1], erase_exception[2], erase_exception[3], 
					erase_exception[4], erase_exception[5], erase_exception[6], erase_exception[7], 
					erase_exception[8], erase_exception[9], erase_exception[10], erase_exception[11], 
					erase_exception[12], erase_exception[13], erase_exception[14], erase_exception[15]});
					exception_ptr := 0;
					goto s3;}	//erase
				cmd == 58:{response_buf := {r1resp,ocr}; response_size := 40-1; goto s3;}	//read ocr
				else: goto s0;
			}
		}
		MISO = HIGH;
	}
	func block_data_valid {
		block_data := read_block_data;
	}
	state s3 {
		if(rising_edge) {
			if(response_buf_bit_pos == response_size) {
				response_buf_bit_pos := 0;
				if(read_op) {
					goto s4;
				}else if(write_op){
					goto s5;
				}else if(busy_flag){
					goto busy;
				}else {
					goto s0;
				}
			} else {
				response_buf_bit_pos++;
			}
		}
		MISO = response_buf[response_size-response_buf_bit_pos];
	}
	state s4 {
		if(rising_edge) {
			if(block_bit_pos == (block_size-1)) {
				block_bit_pos := 0;
				read_op := 0;
				goto s0;
			} else {
				block_bit_pos++;
			}
		}
		MISO = block_data[block_bit_pos];
	}
	state s5{	//recv start byte
		if(rising_edge) {
				if({start_byte_buf[6:0], MOSI} == start_byte) {
					start_byte_buf := 0;
					goto s6;
				} else {
					start_byte_buf := {start_byte_buf[6:0], mosi};
				}
			}
		MISO = HIGH;
	}
	state s6{	//send block data
			if(rising_edge) {
				if(block_bit_pos == (4096-1)) {
					//valid({data_block[4094:0], miso});
					block_bit_pos := 0;
					goto s7;
				} else {
					block_bit_pos++;
				}
				block_data := {block_data[4094:0], mosi};
			}
		MISO = HIGH;
	}
	state s7{	//recv crc
		reg crc_bit_pos[4] = 0;

			if(rising_edge) {
				if(crc_bit_pos == (16-1)) {
					crc_bit_pos := 0;
					goto s8;
				} else {
					crc_bit_pos++;
				}
				//crc := {crc[14:0], miso};
			}
		MISO = HIGH;
	}
	state s8{	//send data resp
		reg write_response[8] = 0x05;
		if(rising_edge) {
			if(response_buf_bit_pos == 7) {
				response_buf_bit_pos := 0;
				write_op := 0;
				write(cmd_buf[39:8], block_data);
				goto s0;
			} else {
				response_buf_bit_pos++;
			}
		}
		MISO = write_response[response_size-response_buf_bit_pos];//response_buf[response_size-response_buf_bit_pos];
	}
	state busy{
		reg busy_cnt[5] = 0;
		if(rising_edge) {
			if(busy_cnt == 31) {
				busy_cnt := 0;
				busy_flag := 0;
				goto s0;
			} else {
				busy_cnt++;
			}
		}
		MISO = LOW;
	}
}
