#include "mmcspi.h"

#define MEM_WORD        3'b010
#define MEM_HALFWORD    3'b001
#define MEM_BYTE        3'b000

#define CLK_100KHZ_COUNT 250
#define TM_1MS_COUNT	65535
#define DUMMY_CLOCK_COUNT 80
#define SIZE_1_BYTE		8
#define SIZE_5_BYTE		40
#define CSB 1'b0 //cmd_start_bit
#define CTB 1'b1 //cmd_transmission_bit
#define CRC 7'b0000000 //disabled
#define CEB 1'b1 //cmd_end_bit
#define READ_TOKEN 8'b11111110
#define MULTI_WRITE_TOKEN 8'b11111100
#define STOP_TOKEN 8'b11111101
#define ACCEPTED 4'b0101
#define RES_R1B 2'b00
#define RES_R1 2'b01
#define RES_R2 2'b10
#define RES_R3 2'b11

module mmcspi {
	reg clk_cnt[8] = 0;
	reg clk_100khz = 0;
	reg clk_25mhz = 0;
	reg clk_prev_100khz = 0;
	reg clk_prev_25mhz = 0;
	reg clk_prev_m_clock = 0;
	wire clk_prev;
	wire clk;
	func_self falling_edge();
	func_self rising_edge();
	reg miso_r = 1;
	wire miso;
	proc_name init();
	proc_name idle();
	reg cmd_buf[48];
	reg response[2];
	reg response_buf[40];
    reg data_resp[8] = -1;
	proc_name send_cmd(cmd_buf, response);
	proc_name receive_response(response_buf, response);
	mem read_data_block[512][8];
	mem write_data_block[128][32];//reg write_data_block[4096] = -1;

	wire word_align[10];
	wire response_upper[32];
	wire response_lower[32];
	operation_t reg operation = 0;
	reg operation_adrs[32] = 0;
	reg cmd[6];
	reg arg[32];
	reg resp[32];
    reg r1state[8];
	status_t reg status = 0;

	clk = if(status.inited) clk_25mhz else clk_100khz;
	clk_prev = if(status.inited) clk_prev_25mhz else clk_prev_100khz;
	miso = if(status.inited) MISO else miso_r;
	if(((((clk_cnt == CLK_100KHZ_COUNT)) && ~clk && ~~clk_prev) && ~status.inited) || (clk && ~clk_prev && status.inited)) {
		rising_edge();
	}
	if(((((clk_cnt == CLK_100KHZ_COUNT)) && ~~clk && ~clk_prev) && ~status.inited) || (~clk && clk_prev && status.inited)) {
		falling_edge();
	}
	/*
	if(rising_edge) {
		miso_r := MISO;
	}
	*/
	if((clk_cnt == CLK_100KHZ_COUNT) && ~status.inited) {
		miso_r := MISO;
	} else if(status.inited) {
		miso_r := MISO;
	}
	if(clk_cnt == CLK_100KHZ_COUNT) {
		clk_cnt := 0;
		clk_100khz := ~clk_100khz;
		clk_prev_100khz := clk_100khz;
	} else {
		clk_cnt++;
	}
	clk_25mhz := ~clk_25mhz;
	clk_prev_25mhz := clk_25mhz;

	func reset {
		status.inited := 0;
		init();
	}
	proc init {
		state_name poweron, dummy_clock, recv_cmd0_resp, recv_cmd1_resp, recv_cmd16_resp;

		state poweron {
			reg poweron_cnt[16] = 0;

			if(poweron_cnt == TM_1MS_COUNT) {
				if(rising_edge) {
					poweron_cnt := 0;

					goto dummy_clock;
				}
			} else {
				poweron_cnt++;
			}
			CS = LOW;
			SCLK = LOW;
			MOSI = LOW;
		}
		state dummy_clock {
			reg dummy_clock_cnt[7] = 0;

			if(rising_edge) {
				if(dummy_clock_cnt == DUMMY_CLOCK_COUNT) {
					dummy_clock_cnt := 0;

					send_cmd(CMD0, RES_R1);
					goto recv_cmd0_resp;
				} else {
					dummy_clock_cnt++;
				}
			}
			CS = HIGH;
			SCLK = clk;
			MOSI = HIGH;
		}
		state recv_cmd0_resp {
			if(rising_edge) {
				if(response_buf[7:0] == 0x01){
					send_cmd(CMD1, RES_R1);
					goto recv_cmd1_resp;
					#ifdef CV
					#endif
				}else{
					send_cmd(CMD0, RES_R1);
				}
			}
			CS = HIGH;
			SCLK = clk;
			MOSI = HIGH;
		}
		state recv_cmd1_resp{
			if(rising_edge) {
				if(response_buf[7:0] == 0x00) {
					send_cmd(CMD16, RES_R1);
					goto recv_cmd16_resp;
					#ifdef CV
					#endif
				}else{
					send_cmd(CMD1, RES_R1);
					#ifdef CV
					#endif
				}
			}
			CS = HIGH;
			SCLK = clk;
			MOSI = HIGH;
		}
		state recv_cmd16_resp {
			if(rising_edge) {

				goto poweron;
				idle();
					#ifdef CV
					#endif
			}
			CS = HIGH;
			SCLK = clk;
			MOSI = HIGH;
		}
	}
	proc send_cmd {
		reg cmd_buf_bit_pos[7] = 48;

		if(rising_edge) {
			if((cmd_buf_bit_pos-1) == 0) {
				cmd_buf_bit_pos := 48;
				receive_response(0xffffffffff, response);
				#ifdef CV
				if(SW[5]){
					debug_led_4();
				}
				#endif
			} else {
				cmd_buf_bit_pos--;
			}
		}
		CS = LOW;
		SCLK = clk;
		MOSI = cmd_buf[cmd_buf_bit_pos-1];
	}
	proc receive_response {
		reg response_buf_bit_pos[6] = 0;
		state_name receive_start_bit, receive_response_body, r1b_busy_wait;
        reg response_size[6] = 0;
		
		state receive_start_bit {
			if(miso == LOW) {
				if(rising_edge) {
					response_buf := {response_buf[38:0], miso};
					response_buf_bit_pos++;
                    any{
                        response[1] == 0: response_size := 8; //RES_R1 or RES_R1B
                        response == RES_R2: response_size := 16;
                        response == RES_R3: response_size := 40;
                    }
					goto receive_response_body;
					#ifdef CV
					if(SW[5]){
						debug_led_5();
					}
					#endif
				}
			}
		}
		state receive_response_body {
			if(rising_edge) {
				if(response_buf_bit_pos == (response_size-1)) {
					response_buf_bit_pos := 0;
                    any{
                        response[1] == 0: r1state := {response_buf[6:0],miso}; //RES_R1 or RES_R1B
                        response == RES_R2:{
							r1state := {response_buf[14:7]};
							resp := {response_buf[6:0],miso};
						}
                        response == RES_R3:{
							r1state := {response_buf[38:31]};
							resp := {response_buf[30:0],miso};
						} 
                    }
                    if(response == RES_R1B){
                        goto r1b_busy_wait;
                    }else if(!status.inited) {
						init();
					    goto receive_start_bit;
					} else {
						idle();
					    goto receive_start_bit;
					}
					#ifdef CV
					if(SW[5]){
						debug_led_6();
					}
					#endif
				} else {
					response_buf_bit_pos++;
				}
				response_buf := {response_buf[38:0], miso};
			}
		}
        state r1b_busy_wait {
            reg r1b_busy[8] = 0;
			if(rising_edge) {
                if({r1b_busy[6:0],miso} == 0xFF) {
                    idle();
                    goto receive_start_bit;
					#ifdef CV
					if(SW[5]){
						debug_led_7();
					}
					#endif
                }
				r1b_busy := {r1b_busy[6:0], miso};	
			}
        }
		CS = LOW;
		SCLK = clk;
		MOSI = HIGH;
	}
	proc idle {
		state_name s0, s1, s2, send_irq;
		state_name recv_data_packet_start_byte, recv_data_packet_data_block, recv_data_packet_crc;
		state_name send_data_packet_start_byte, send_data_packet_data_block, send_data_packet_crc, recv_data_resp;
		reg start_byte_buf[8] = 0;
		reg start_byte[8] = 0xfe;
		reg recieve_size[13] = 4096;
		reg crc[16] = 0;

		status.inited := HIGH;

		state s0 {
			reg s0_cnt[8] = 0;
			/* change 100khz to 25mhz, sync to rising_edge */
			if(rising_edge) {
				if(s0_cnt == 0xff) {
					s0_cnt := 0;
					goto s1;
				} else {
					s0_cnt++;
				}
			}
			CS = HIGH;
			SCLK = LOW;
			MOSI = HIGH;
		}

		state s1 {
            wire res[2];
            if(status.exec == HIGH){
                any {
                    cmd == 27 || cmd == 28 || cmd == 29 || cmd == 38 || cmd == 42: res = RES_R1B;
                    cmd == 13: res = RES_R2;
                    cmd == 58: res = RES_R3;
                    else: res = RES_R1;
                }
                send_cmd({CSB,CTB,cmd,arg,CRC,CEB},res);
                goto s2;
            }
		    status.idle := !status.exec;
			CS = HIGH;
			SCLK = clk;
			MOSI = HIGH;
			#ifdef CV
			if(SW[5]){
				any{
					status.inited: debug_led_1();
					status.idle: debug_led_2();
					status.exec: debug_led_3();
				}
			}
			#endif
		}
        state s2{
            if(r1state == 0x00){
                any {
                    cmd == 9 | cmd == 10 | cmd == 17 | cmd == 18 | cmd == 51: goto recv_data_packet_start_byte;
                    cmd == 24 | cmd == 25: goto send_data_packet_start_byte;
					else: goto send_irq;
                }
				any{
                    cmd == 9 | cmd == 10 | cmd == 17 | cmd == 18 | cmd == 24 | cmd == 51: start_byte := 0xfe;
                    cmd == 25: start_byte := 0xfc;
				}
            }else{
                goto send_irq;
            }
			start_byte_buf := {start_byte_buf[6:0], miso};
			CS = LOW;
			SCLK = clk;
			MOSI = HIGH;
        }
		state recv_data_packet_start_byte {
			if(rising_edge) {
				if({start_byte_buf[6:0], miso} == start_byte) {
					start_byte_buf := 0;
					goto recv_data_packet_data_block;
				} else {
					start_byte_buf := {start_byte_buf[6:0], miso};
				}
			}
			CS = LOW;
			SCLK = clk;
			MOSI = HIGH;

		}
		state recv_data_packet_data_block {
			reg data_block_bit_pos[13] = 0;
			reg read_data_buffer[8] = 0;
			reg bit_cnt[3];
			reg byte_cnt[9];

			if(rising_edge) {
				if(byte_cnt == (512-1) && bit_cnt == (SIZE_1_BYTE-1)) {
					read_data_buffer := 0;
					bit_cnt := 0;
					byte_cnt := 0;
					goto recv_data_packet_crc;
				} else {
					read_data_buffer := {read_data_buffer[7:0], miso};
				}
				if(bit_cnt == (SIZE_1_BYTE-1)){
					bit_cnt := 0;
					byte_cnt++;
					read_data_block[byte_cnt] := {read_data_buffer[7:0], miso};
				}else{
					bit_cnt++;
				}
			}
			CS = LOW;
			SCLK = clk;
			MOSI = HIGH;

		}
		state recv_data_packet_crc {
			reg crc_bit_pos[4] = 0;

			if(rising_edge) {
				if(crc_bit_pos == (16-1)) {
					crc_bit_pos := 0;
					if(cmd == 18){
						goto recv_data_packet_start_byte;
					}else{
						goto send_irq;
					}
				} else {
					crc_bit_pos++;
				}
				crc := {crc[14:0], miso};
			}
			CS = LOW;
			SCLK = clk;
			MOSI = HIGH;

		}
		state send_data_packet_start_byte {
			reg start_byte_send_bit_pos[3] = 7;

			if(rising_edge) {
				if(start_byte_send_bit_pos == 0) {
					start_byte_send_bit_pos := 7;
					goto send_data_packet_data_block;
				} else {
					start_byte_send_bit_pos--;
				}
			}
			CS = LOW;
			SCLK = clk;
			MOSI = start_byte[start_byte_send_bit_pos];

		}
		state send_data_packet_data_block {
			//reg write_data_block_bit_pos[12] = 4095;
			reg write_data_column[7] = 0;
			reg write_data_row[5] = 0;
			wire sending_word[32];
			
			if(rising_edge) {
				if(write_data_column == (128-1) && write_data_row == (32-1)) {
					//write_data_block_bit_pos := 4095;
					write_data_column := 0;
					write_data_row := 0;
					goto send_data_packet_crc;
				} else if(write_data_row != (32-1)){
					//write_data_block_bit_pos--;
					write_data_row++;
				} else {
					write_data_column++;
					write_data_row := 0;
				}
			}
			sending_word = write_data_block[write_data_column];
			CS = LOW;
			SCLK = clk;
            MOSI = sending_word[write_data_row];
			//MOSI = write_data_block[write_data_block_bit_pos];

		}
		state send_data_packet_crc {
			reg crc_send_bit_pos[4] = 15;
			
			if(rising_edge) {
				if(crc_send_bit_pos == 0) {
					crc_send_bit_pos := 15;
					goto recv_data_resp;
				} else {
					crc_send_bit_pos--;
				}
			}
			CS = LOW;
			SCLK = clk;
			MOSI = 1'b0;

		}
		state recv_data_resp {
			reg data_resp_bit_pos[3] = 7;

			if(rising_edge) {
				if(data_resp_bit_pos == 0) {
					data_resp_bit_pos := 7;
					if({data_resp[6:0],miso} != 0xFF) {
						if({data_resp[2:0],miso} == ACCEPTED){
                            if(cmd == 25){
                                goto send_data_packet_start_byte;
                            }else{
							    goto send_irq;
                            }
						}else{
							goto s1;
						}
					}
				} else {
					data_resp_bit_pos--;
				}
				data_resp := {data_resp[6:0], miso};	
			}
			CS = LOW;
			SCLK = clk;
			MOSI = HIGH;
		}
        state send_irq{
			if(rising_edge){
				if(status.interrupt_enable){
					interrupt_req();
				}
				status.exec := LOW;
            	goto s1;
			}
			CS = HIGH;
			SCLK = clk;
			MOSI = HIGH;
        }
	}
	func read {
		wire read_data[32];
		
		word_align = read_adrs[11:2];
		response_lower = response_buf[31:0];
		response_upper = {0x000000, response_buf[39:32]};

		any {
			read_adrs < 12'(0x200):{read_data = {read_data_block[word_align+3],read_data_block[word_align+2],read_data_block[word_align+1],read_data_block[word_align]};}
			read_adrs == 12'(0x200): {read_data = 32'(status);}
			read_adrs == 12'(0x204): {read_data = 32'(r1state);}
			read_adrs == 12'(0x208): {read_data = resp;}
			read_adrs == 12'(0x20c): {read_data = 32'(cmd);}
			read_adrs == 12'(0x210): {read_data = 32'(arg);}
			read_adrs <= 12'(0x210): {valid();}
			else: load_access_fault();
		}
		
		any {
			(byteen == MEM_WORD):								rdata = read_data;
			(byteen == MEM_HALFWORD && ~read_adrs[1]):			rdata = {0x0000, read_data[15:0]};
			(byteen == MEM_HALFWORD && read_adrs[1]):			rdata = {0x0000, read_data[31:16]};
			(byteen == MEM_BYTE && (read_adrs[1:0] == 2'b00)):	rdata = {0x000000, read_data[7:0]};
			(byteen == MEM_BYTE && (read_adrs[1:0] == 2'b01)):	rdata = {0x000000, read_data[15:8]};
			(byteen == MEM_BYTE && (read_adrs[1:0] == 2'b10)):	rdata = {0x000000, read_data[23:16]};
			(byteen == MEM_BYTE && (read_adrs[1:0] == 2'b11)):	rdata = {0x000000, read_data[31:24]};
		}
	}
	func write {
		variable new_data[32];
		wire old_data[32];
		old_data = write_data_block[word_align];
		word_align = write_adrs[11:2];
		
		any {
			write_adrs < 12'(0x200): {
				any {
					(byteen == MEM_WORD):								{new_data[31:0] = {wdata[7:0],wdata[15:8],wdata[23:16],wdata[31:24]};}
					(byteen == MEM_HALFWORD && ~write_adrs[1]):			{new_data[31:16] = old_data[31:16]; new_data[15:0] = {wdata[7:0],wdata[15:8]};}
					(byteen == MEM_HALFWORD && write_adrs[1]):			{new_data[31:16] = {wdata[7:0],wdata[15:8]}; new_data[15:0] = old_data[15:0];}
					(byteen == MEM_BYTE && (write_adrs[1:0] == 2'b00)):	{new_data[31:24] = wdata[7:0]; new_data[23:0] = old_data[23:0];}
					(byteen == MEM_BYTE && (write_adrs[1:0] == 2'b01)):	{new_data[31:24] = old_data[31:24]; new_data[23:16] = wdata[7:0]; new_data[15:0] = old_data[15:0];}
					(byteen == MEM_BYTE && (write_adrs[1:0] == 2'b10)):	{new_data[31:16] = old_data[31:16]; new_data[15:8] = wdata[7:0]; new_data[7:0] = old_data[7:0];}
					(byteen == MEM_BYTE && (write_adrs[1:0] == 2'b11)):	{new_data[31:8] = old_data[31:8]; new_data[7:0] = wdata[7:0];}
				}
			write_data_block[word_align] := new_data;
			}
			write_adrs == 12'(0x200): {status.interrupt_enable := wdata[3]; status.exec := wdata[2];}
			write_adrs == 12'(0x20c): {cmd := wdata[5:0];}
			write_adrs == 12'(0x210): {arg := wdata;}
			write_adrs <= 12'(0x210): {valid();}
			else: store_amo_access_fault();
		}
	}
}
